{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Component, ViewEncapsulation, ViewChild, ContentChild, Input, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nconst _c0 = [\"canvas\"];\nconst _c1 = [\"rLabel\"];\nconst _c2 = [\"reading\"];\n\nfunction NgxGauge_ng_content_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 0, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\n\nfunction NgxGauge_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.prepend);\n  }\n}\n\nfunction NgxGauge_ng_content_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 1, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\n\nfunction NgxGauge_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"number\");\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(2, 1, ctx_r4.value));\n  }\n}\n\nfunction NgxGauge_ng_content_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 2, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\n\nfunction NgxGauge_ng_container_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r6.append);\n  }\n}\n\nfunction NgxGauge_ng_content_13_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0, 3, [\"*ngSwitchCase\", \"true\"]);\n  }\n}\n\nfunction NgxGauge_ng_container_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r9.label);\n  }\n}\n\nconst _c3 = [[[\"ngx-gauge-prepend\"]], [[\"ngx-gauge-value\"]], [[\"ngx-gauge-append\"]], [[\"ngx-gauge-label\"]]];\nconst _c4 = [\"ngx-gauge-prepend\", \"ngx-gauge-value\", \"ngx-gauge-append\", \"ngx-gauge-label\"];\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction coerceBooleanProperty(value) {\n  return value != null && `${value}` !== 'false';\n}\n\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n  return isNaN(parseFloat(value)) || isNaN(Number(value)) ? fallbackValue : Number(value);\n}\n\nfunction cssUnit(value) {\n  return `${value}px`;\n}\n\nfunction isNumber(value) {\n  return value != undefined && !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n\nlet NgxGaugeAppend = /*#__PURE__*/(() => {\n  class NgxGaugeAppend {}\n\n  NgxGaugeAppend.ɵfac = function NgxGaugeAppend_Factory(t) {\n    return new (t || NgxGaugeAppend)();\n  };\n\n  NgxGaugeAppend.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeAppend,\n    selectors: [[\"ngx-gauge-append\"]],\n    exportAs: [\"ngxGaugeAppend\"]\n  });\n  return NgxGaugeAppend;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxGaugePrepend = /*#__PURE__*/(() => {\n  class NgxGaugePrepend {}\n\n  NgxGaugePrepend.ɵfac = function NgxGaugePrepend_Factory(t) {\n    return new (t || NgxGaugePrepend)();\n  };\n\n  NgxGaugePrepend.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugePrepend,\n    selectors: [[\"ngx-gauge-prepend\"]],\n    exportAs: [\"ngxGaugePrepend\"]\n  });\n  return NgxGaugePrepend;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxGaugeValue = /*#__PURE__*/(() => {\n  class NgxGaugeValue {}\n\n  NgxGaugeValue.ɵfac = function NgxGaugeValue_Factory(t) {\n    return new (t || NgxGaugeValue)();\n  };\n\n  NgxGaugeValue.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeValue,\n    selectors: [[\"ngx-gauge-value\"]],\n    exportAs: [\"ngxGaugeValue\"]\n  });\n  return NgxGaugeValue;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxGaugeLabel = /*#__PURE__*/(() => {\n  class NgxGaugeLabel {}\n\n  NgxGaugeLabel.ɵfac = function NgxGaugeLabel_Factory(t) {\n    return new (t || NgxGaugeLabel)();\n  };\n\n  NgxGaugeLabel.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxGaugeLabel,\n    selectors: [[\"ngx-gauge-label\"]],\n    exportAs: [\"ngxGaugeLabel\"]\n  });\n  return NgxGaugeLabel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst DEFAULTS = {\n  MIN: 0,\n  MAX: 100,\n  TYPE: 'arch',\n  THICK: 4,\n  FOREGROUND_COLOR: 'rgba(0, 150, 136, 1)',\n  BACKGROUND_COLOR: 'rgba(0, 0, 0, 0.1)',\n  CAP: 'butt',\n  SIZE: 200\n};\nlet NgxGauge = /*#__PURE__*/(() => {\n  class NgxGauge {\n    constructor(_elementRef, _renderer) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._size = DEFAULTS.SIZE;\n      this._min = DEFAULTS.MIN;\n      this._max = DEFAULTS.MAX;\n      this._animate = true;\n      this._initialized = false;\n      this._animationRequestID = 0;\n      this.ariaLabel = '';\n      this.ariaLabelledby = null;\n      this.type = DEFAULTS.TYPE;\n      this.cap = DEFAULTS.CAP;\n      this.thick = DEFAULTS.THICK;\n      this.foregroundColor = DEFAULTS.FOREGROUND_COLOR;\n      this.backgroundColor = DEFAULTS.BACKGROUND_COLOR;\n      this.thresholds = Object.create(null);\n      this._value = 0;\n      this.duration = 1200;\n    }\n\n    get size() {\n      return this._size;\n    }\n\n    set size(value) {\n      this._size = coerceNumberProperty(value);\n    }\n\n    get min() {\n      return this._min;\n    }\n\n    set min(value) {\n      this._min = coerceNumberProperty(value, DEFAULTS.MIN);\n    }\n\n    get animate() {\n      return this._animate;\n    }\n\n    set animate(value) {\n      this._animate = coerceBooleanProperty(value);\n    }\n\n    get max() {\n      return this._max;\n    }\n\n    set max(value) {\n      this._max = coerceNumberProperty(value, DEFAULTS.MAX);\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set value(val) {\n      this._value = coerceNumberProperty(val);\n    }\n\n    ngOnChanges(changes) {\n      const isCanvasPropertyChanged = changes['thick'] || changes['type'] || changes['cap'] || changes['size'];\n      const isDataChanged = changes['value'] || changes['min'] || changes['max'];\n\n      if (this._initialized) {\n        if (isDataChanged) {\n          let nv, ov;\n\n          if (changes['value']) {\n            nv = changes['value'].currentValue;\n            ov = changes['value'].previousValue;\n          }\n\n          this._update(nv, ov);\n        }\n\n        if (isCanvasPropertyChanged) {\n          this._destroy();\n\n          this._init();\n        }\n      }\n    }\n\n    _updateSize() {\n      this._renderer.setStyle(this._elementRef.nativeElement, 'width', cssUnit(this._getWidth()));\n\n      this._renderer.setStyle(this._elementRef.nativeElement, 'height', cssUnit(this._getCanvasHeight()));\n\n      this._canvas.nativeElement.width = this._getWidth();\n      this._canvas.nativeElement.height = this._getCanvasHeight();\n\n      this._renderer.setStyle(this._label.nativeElement, 'transform', 'translateY(' + (this.size / 3 * 2 - this.size / 13 / 4) + 'px)');\n\n      this._renderer.setStyle(this._reading.nativeElement, 'transform', 'translateY(' + (this.size / 2 - this.size * 0.22 / 2) + 'px)');\n    }\n\n    ngAfterViewInit() {\n      if (this._canvas) {\n        this._init();\n      }\n    }\n\n    ngOnDestroy() {\n      this._destroy();\n    }\n\n    _getBounds(type) {\n      let head, tail;\n\n      if (type == 'semi') {\n        head = Math.PI;\n        tail = 2 * Math.PI;\n      } else if (type == 'full') {\n        head = 1.5 * Math.PI;\n        tail = 3.5 * Math.PI;\n      } else if (type === 'arch') {\n        head = 0.8 * Math.PI;\n        tail = 2.2 * Math.PI;\n      }\n\n      return {\n        head,\n        tail\n      };\n    }\n\n    _drawShell(start, middle, tail, color) {\n      let center = this._getCenter(),\n          radius = this._getRadius();\n\n      middle = Math.max(middle, start); // never below 0%\n\n      middle = Math.min(middle, tail); // never exceed 100%\n\n      if (this._initialized) {\n        this._clear();\n\n        this._context.beginPath();\n\n        this._context.strokeStyle = this.backgroundColor;\n\n        this._context.arc(center.x, center.y, radius, middle, tail, false);\n\n        this._context.stroke();\n\n        this._context.beginPath();\n\n        this._context.strokeStyle = color;\n\n        this._context.arc(center.x, center.y, radius, start, middle, false);\n\n        this._context.stroke();\n      }\n    }\n\n    _clear() {\n      this._context.clearRect(0, 0, this._getWidth(), this._getHeight());\n    }\n\n    _getWidth() {\n      return this.size;\n    }\n\n    _getHeight() {\n      return this.size;\n    } // canvas height will be shorter for type 'semi' and 'arch'\n\n\n    _getCanvasHeight() {\n      return this.type == 'arch' || this.type == 'semi' ? 0.85 * this._getHeight() : this._getHeight();\n    }\n\n    _getRadius() {\n      var center = this._getCenter();\n\n      return center.x - this.thick;\n    }\n\n    _getCenter() {\n      var x = this._getWidth() / 2,\n          y = this._getHeight() / 2;\n      return {\n        x,\n        y\n      };\n    }\n\n    _init() {\n      this._context = this._canvas.nativeElement.getContext('2d');\n      this._initialized = true;\n\n      this._updateSize();\n\n      this._setupStyles();\n\n      this._create();\n    }\n\n    _destroy() {\n      if (this._animationRequestID) {\n        window.cancelAnimationFrame(this._animationRequestID);\n        this._animationRequestID = 0;\n      }\n\n      this._clear();\n\n      this._context = null;\n      this._initialized = false;\n    }\n\n    _setupStyles() {\n      this._context.lineCap = this.cap;\n      this._context.lineWidth = this.thick;\n    }\n\n    _getForegroundColorByRange(value) {\n      const match = Object.keys(this.thresholds).filter(function (item) {\n        return isNumber(item) && Number(item) <= value;\n      }).sort((a, b) => Number(a) - Number(b)).reverse()[0];\n      return match !== undefined ? this.thresholds[match].color || this.foregroundColor : this.foregroundColor;\n    }\n\n    _create(nv, ov) {\n      let self = this,\n          type = this.type,\n          bounds = this._getBounds(type),\n          duration = this.duration,\n          min = this.min,\n          max = this.max,\n          value = clamp(this.value, this.min, this.max),\n          start = bounds.head,\n          unit = (bounds.tail - bounds.head) / (max - min),\n          displacement = unit * (value - min),\n          tail = bounds.tail,\n          color = this._getForegroundColorByRange(value),\n          startTime;\n\n      if (self._animationRequestID) {\n        window.cancelAnimationFrame(self._animationRequestID);\n      }\n\n      function animate(timestamp) {\n        timestamp = timestamp || new Date().getTime();\n        let runtime = timestamp - startTime;\n        let progress = Math.min(runtime / duration, 1);\n        let previousProgress = ov ? (ov - min) * unit : 0;\n        let middle = start + previousProgress + displacement * progress;\n\n        self._drawShell(start, middle, tail, color);\n\n        if (self._animationRequestID && runtime < duration) {\n          self._animationRequestID = window.requestAnimationFrame(timestamp => animate(timestamp));\n        } else {\n          window.cancelAnimationFrame(self._animationRequestID);\n        }\n      }\n\n      if (this._animate) {\n        if (nv != undefined && ov != undefined) {\n          displacement = unit * nv - unit * ov;\n        }\n\n        self._animationRequestID = window.requestAnimationFrame(timestamp => {\n          startTime = timestamp || new Date().getTime();\n          animate(startTime);\n        });\n      } else {\n        self._drawShell(start, start + displacement, tail, color);\n      }\n    }\n\n    _update(nv, ov) {\n      this._clear();\n\n      this._create(nv, ov);\n    }\n\n  }\n\n  NgxGauge.ɵfac = function NgxGauge_Factory(t) {\n    return new (t || NgxGauge)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n\n  NgxGauge.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxGauge,\n    selectors: [[\"ngx-gauge\"]],\n    contentQueries: function NgxGauge_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeLabel, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugePrepend, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeAppend, 5);\n        i0.ɵɵcontentQuery(dirIndex, NgxGaugeValue, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._labelChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._prependChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._appendChild = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._valueDisplayChild = _t.first);\n      }\n    },\n    viewQuery: function NgxGauge_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n        i0.ɵɵviewQuery(_c1, 7);\n        i0.ɵɵviewQuery(_c2, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._canvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._label = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._reading = _t.first);\n      }\n    },\n    hostAttrs: [\"role\", \"slider\", \"aria-readonly\", \"true\"],\n    hostVars: 7,\n    hostBindings: function NgxGauge_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-valuemin\", ctx.min)(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.value)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledby);\n        i0.ɵɵclassProp(\"ngx-gauge-meter\", true);\n      }\n    },\n    inputs: {\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      size: \"size\",\n      min: \"min\",\n      animate: \"animate\",\n      max: \"max\",\n      type: \"type\",\n      cap: \"cap\",\n      thick: \"thick\",\n      label: \"label\",\n      append: \"append\",\n      prepend: \"prepend\",\n      foregroundColor: \"foregroundColor\",\n      backgroundColor: \"backgroundColor\",\n      thresholds: \"thresholds\",\n      value: \"value\",\n      duration: \"duration\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c4,\n    decls: 17,\n    vars: 16,\n    consts: [[1, \"reading-block\"], [\"reading\", \"\"], [1, \"reading-affix\", 3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [3, \"ngSwitch\"], [1, \"reading-label\", 3, \"ngSwitch\"], [\"rLabel\", \"\"], [\"canvas\", \"\"]],\n    template: function NgxGauge_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c3);\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵelementStart(2, \"u\", 2);\n        i0.ɵɵtemplate(3, NgxGauge_ng_content_3_Template, 1, 0, \"ng-content\", 3);\n        i0.ɵɵtemplate(4, NgxGauge_ng_container_4_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainerStart(5, 4);\n        i0.ɵɵtemplate(6, NgxGauge_ng_content_6_Template, 1, 0, \"ng-content\", 3);\n        i0.ɵɵtemplate(7, NgxGauge_ng_container_7_Template, 3, 3, \"ng-container\", 3);\n        i0.ɵɵelementContainerEnd();\n        i0.ɵɵelementStart(8, \"u\", 2);\n        i0.ɵɵtemplate(9, NgxGauge_ng_content_9_Template, 1, 0, \"ng-content\", 3);\n        i0.ɵɵtemplate(10, NgxGauge_ng_container_10_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"div\", 5, 6);\n        i0.ɵɵtemplate(13, NgxGauge_ng_content_13_Template, 1, 0, \"ng-content\", 3);\n        i0.ɵɵtemplate(14, NgxGauge_ng_container_14_Template, 2, 1, \"ng-container\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(15, \"canvas\", null, 7);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"font-size\", ctx.size * 0.22 + \"px\");\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitch\", ctx._prependChild != null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitch\", ctx._valueDisplayChild != null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitch\", ctx._appendChild != null);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"font-size\", ctx.size / 13 + \"px\");\n        i0.ɵɵproperty(\"ngSwitch\", ctx._labelChild != null);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngSwitchCase\", true);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", false);\n      }\n    },\n    directives: [i1.NgSwitch, i1.NgSwitchCase],\n    pipes: [i1.DecimalPipe],\n    styles: [\".ngx-gauge-meter{display:inline-block;text-align:center;position:relative}.reading-block,.reading-label{position:absolute;width:100%;font-weight:400;white-space:nowrap;text-align:center;overflow:hidden;text-overflow:ellipsis}.reading-label{font-family:inherit;display:inline-block}.reading-affix{text-decoration:none;font-size:.6em;opacity:.8;font-weight:200;padding:0 .18em}.reading-affix:first-child{padding-left:0}.reading-affix:last-child{padding-right:0}\"],\n    encapsulation: 2\n  });\n  return NgxGauge;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxGaugeModule = /*#__PURE__*/(() => {\n  class NgxGaugeModule {}\n\n  NgxGaugeModule.ɵfac = function NgxGaugeModule_Factory(t) {\n    return new (t || NgxGaugeModule)();\n  };\n\n  NgxGaugeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxGaugeModule\n  });\n  NgxGaugeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NgxGaugeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public APIs of ngx-gauge\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { NgxGauge, NgxGaugeAppend, NgxGaugeLabel, NgxGaugeModule, NgxGaugePrepend, NgxGaugeValue }; //# sourceMappingURL=ngx-gauge.js.map","map":null,"metadata":{},"sourceType":"module"}